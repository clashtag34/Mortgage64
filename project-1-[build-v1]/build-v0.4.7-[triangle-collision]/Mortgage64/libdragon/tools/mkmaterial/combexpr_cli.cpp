#include <stdio.h>
#include <string.h>
#include "json.hpp"
#include "combexpr.cpp"

using json = nlohmann::json;

extern "C" char* rdpq_debug_disasm_cc(uint64_t cc64);

int flag_verbose = 0;
bool flag_json = false;

int selftest(void)
{
    int run = 0;
    int failed = 0;

    auto check = [&](std::string expr, std::string expected) {
        run++;
        std::string error;
        auto got = combexpr::parse(expr, "0", &error).channels[0].to_string();
        if (!error.empty()) {
            if (expected != "<ERROR>") {
                fprintf(stderr, "FAIL: %s: %s\n", expr.c_str(), error.c_str());
                failed++;
            }
            return;
        }
        if (got != expected) {
            combexpr::Parser parser(expr);
            auto root = parser.parseExpression();
            combexpr::printTree(root);
            fprintf(stderr, "FAIL: %s: expected: %s, got: %s\n", expr.c_str(), expected.c_str(), got.c_str());
            failed++;
        }
    };

    check("tex0", "(1,0,0,tex0)");
    check("tex0 + tex1", "(1,0,tex1,tex0),(0,0,0,combined)");
    check("tex0 * shade + tex1", "(shade,0,tex0,tex1),(0,0,0,combined)");
    check("tex0 + tex1 * shade", "(shade,0,tex1,tex0),(0,0,0,combined)");
    check("tex0 + tex1 * (shade - env)", "(shade,env,tex1,tex0),(0,0,0,combined)");
    check("tex0 + tex1 * (shade + env)", "(1,0,env,shade),(combined,0,tex1,tex0)");
    check("(prim - env) * tex0 + env", "(prim,env,tex0,env)");
    check("tex0 * 0.3", "(env,0,tex0,0)");
    check("tex0 * .3", "(env,0,tex0,0)");
    check("tex0 * prim * env", "(prim,0,tex0,0),(combined,0,env,0)");
    check("prim * env * env * shade", "<ERROR>");
    check("(prim - env) * tex0 + env * k5", "(env,0,k5,0),(prim,env,tex0,combined)");
    check("(prim - env) * tex0 + k5 * env", "(env,0,k5,0),(prim,env,tex0,combined)");
    check("noise", "(noise,0,k5,0)");
    check("noise * 0.2", "(noise,0,k5,0)");
    check("tex0 + noise", "(noise,0,k5,tex0)");
    check("lod_frac", "(1,0,lod_frac,0)");
    check("0.5 * (tex0 + noise)", "(noise,0,k5,tex0),(combined,0,env,0)");
    check("tex0.a * 0.4", "(env,0,tex0.a,0)");
    check("0.5 - tex0.a", "(1,0,tex0.a,0),(env,combined,k5,0)");
    check("tex0.a - 0.5", "(1,0,tex0.a,0),(combined,k4,k5,0)");
    
    fprintf(stderr, "Ran %d tests, %d failed\n", run, failed);
    return failed;
}

void emit_rdpq_code(combexpr::CombinerExprFull& expr, const std::string& rgb_expr, const std::string& alpha_expr)
{
    uint64_t cmd_cc = expr.rdp_command();
    char *disasm = rdpq_debug_disasm_cc(cmd_cc);
    
    printf("//----- Generated by combexpr: rgb='%s' alpha='%s'\n", rgb_expr.c_str(), alpha_expr.c_str());
    printf("rdpq_mode_combiner(%s);\n", disasm);

    for (auto &[name, value] : expr.rdp_uniforms()) {
        if (name == combexpr::UNIFORM_K4K5) {
            printf("rdpq_set_yuv_parms(0,0,0,0,%d,%d);\n", value >> 8, value & 0xFF);
        } else if (name == combexpr::UNIFORM_PRIM_LOD_FRAC) {
            printf("rdpq_set_prim_lod_frac(%d);\n", value);
        } else if (name == combexpr::UNIFORM_ENV) {
            printf("rdpq_set_env_color(RGBA32(%d,%d,%d,%d));\n", (value >> 24) & 0xFF, (value >> 16) & 0xFF, (value >> 8) & 0xFF, value & 0xFF);
        } else if (name == combexpr::UNIFORM_PRIM) {
            printf("rdpq_set_prim_color(RGBA32(%d,%d,%d,%d));\n", (value >> 24) & 0xFF, (value >> 16) & 0xFF, (value >> 8) & 0xFF, value & 0xFF);
        } else {
            fprintf(stderr, "internal error: unknown RDP uniforms: %s\n", combexpr::uniform_name(name).c_str());
            exit(1);
        }
    }

    printf("//-----\n");
    free(disasm);
}

void emit_json(combexpr::CombinerExprFull& expr, const std::string& rgb_expr, const std::string& alpha_expr)
{
    uint64_t cmd_cc = expr.rdp_command();
    auto [rgb_str, alpha_str] = expr.to_string();
    auto [rgb_indices, alpha_indices] = expr.slot_indices();
    json jout;

    jout["input"]["rgb"] = rgb_expr;
    jout["input"]["alpha"] = alpha_expr;
    jout["output"]["rgb"] = rgb_str;
    jout["output"]["alpha"] = alpha_str;
    jout["rdp_command"] = { (uint32_t)(cmd_cc >> 32), (uint32_t)cmd_cc };
    for (auto [id, value] : expr.rdp_uniforms()) {
        std::string name = combexpr::uniform_name(id);
        jout["uniforms"][name] = value;
    }
    jout["steps"] = expr.two_steps() ? 2 : 1;
    jout["slots"]["rgb"] = rgb_indices;
    jout["slots"]["alpha"] = alpha_indices;

    std::cout << jout.dump(4) << std::endl;
}

void usage(const char *name)
{
    fprintf(stderr, "combexpr - Generate rdpq code for a combiner expression\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "Usage: %s <rgb_expr> [<alpha_expr>]\n", name);
    fprintf(stderr, "\n");
    fprintf(stderr, "Command-line flags:\n");
    fprintf(stderr, "   -j/--json                 Output JSON instead of C code (for machine parsing)\n");
    fprintf(stderr, "   -v/--verbose              Verbose output\n");
    fprintf(stderr, "   -h/--help                 Show this help\n");
    fprintf(stderr, "   --selftest                Run internal tests and exit\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "Example:\n");
    fprintf(stderr, "    combexpr   (tex0+prim)*0.8  tex0\n");
}

int main(int argc, char *argv[]) {
    int i;
    for (i = 1; i < argc && argv[i][0] == '-'; i++) {
        if (!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help")) {
            usage(argv[0]);
            return 0;
        } else if (!strcmp(argv[i], "-v") || !strcmp(argv[i], "--verbose")) {
            flag_verbose++;
        } else if (!strcmp(argv[i], "-j") || !strcmp(argv[i], "--json")) {
            flag_json = true;
        } else if (!strcmp(argv[i], "--selftest")) {
            return selftest();
        } else {
            fprintf(stderr, "ERROR: unknown option: %s\n", argv[i]);
            return 1;
        }
    }

    if (i+1 > argc) {
        fprintf(stderr, "ERROR: at least one expression must be provided on the command line\n");
        fprintf(stderr, "Run with -h/--help for help\n");
        return 1;
    }

    std::string rgb_expr = argv[i++];
    std::string alpha_expr = i < argc ? argv[i++] : "0";

    if (i < argc) {
        fprintf(stderr, "ERROR: extra arguments on the command line: ");
        while (i < argc)
            fprintf(stderr, "%s ", argv[i++]);
        fprintf(stderr, "\n");
        return 1;
    }

    std::string error;
    auto expr = combexpr::parse(rgb_expr, alpha_expr, &error);
    if (!error.empty()) {
        fprintf(stderr, "%s\n", error.c_str());
        return 1;
    }

    if (flag_json) {
        emit_json(expr, rgb_expr, alpha_expr);
    } else {
        emit_rdpq_code(expr, rgb_expr, alpha_expr);
    }

    return 0;
}
